#include "ruby.h"

// Defining a space for information and references about the module to be stored internally
VALUE CCustomToS = Qnil;

// Prototype for the initialization method - Ruby calls this, not you
void Init_ccustomtos();

// Prototype for our methods, to be used by Init_ccustomtos
VALUE method_c_custom_to_s(VALUE, VALUE);

// The initialization method for this module
void Init_ccustomtos() {
  CCustomToS = rb_define_module("CCustomToS");
  rb_define_method(CCustomToS, "c_custom_to_s", method_c_custom_to_s, 1);
}

const int MAX_ARRAY_ENUMERATION = 10;
const int MAX_HASH_ENUMERATION = 10;
const int MAX_STRING_LENGTH = 100;
const int MAX_EXPECTED_NESTED_LEVELS = 4;

void method_c_custom_to_s_check_buffer_size(int offset, int string_len, int buffer_max) {
  if (offset + string_len > buffer_max) {
    // don't corrupt the buffer; throw exception
    rb_raise(rb_eRuntimeError, "method_c_custom_t_s_element would write %d bytes outside the buffer", offset + string_len - buffer_max);
  }
}

int method_c_custom_to_s_element(VALUE self, char *buffer, int *offset, VALUE element, int buffer_max, char quoted) {
  switch (TYPE(element)) {
  case T_NIL: {
    int string_len = 3; // +1 for NULL
    method_c_custom_to_s_check_buffer_size(*offset, string_len + 1, buffer_max);
    snprintf(&buffer[*offset], string_len + 1, "%s", "nil");
    *offset += string_len;
    break;
  }
  case T_STRING: {
    VALUE element_to_s = method_c_custom_to_s(self, element);
    int string_len = RSTRING_LEN(element_to_s);
    // +2 for the two "s. +1 for NULL
    method_c_custom_to_s_check_buffer_size(*offset, string_len + 3, buffer_max);
    if (quoted) {
      snprintf(&buffer[*offset], 1 + 1, "%s", "\"");
      *offset += 1;
    }
    // +1 for NULL
    snprintf(&buffer[*offset], string_len + 1, "%s", StringValuePtr(element_to_s));
    *offset += string_len;
    if (quoted) {
      snprintf(&buffer[*offset], 1 + 1, "%s", "\"");
      *offset += 1;
    }
    break;
  }
  default: {
    VALUE element_to_s = method_c_custom_to_s(self, element);
    method_c_custom_to_s_element(self, buffer, offset, element_to_s, buffer_max, 0);
    break;
  }
  }

  return 0;
}

VALUE method_c_custom_to_s_array(VALUE self, VALUE value) {
  VALUE ret;
  // the buffer max size should be "big enough" and it's indeterminate
  int buffer_max = MAX_STRING_LENGTH * MAX_ARRAY_ENUMERATION * MAX_EXPECTED_NESTED_LEVELS;
  char buffer[buffer_max];
  
  int array_len = RARRAY_LEN(value);
  int max_len = array_len;
  int offset = 0;
  int remaining_elements = 0;
  if (max_len > MAX_ARRAY_ENUMERATION) {
    remaining_elements = max_len - MAX_ARRAY_ENUMERATION;
    max_len = MAX_ARRAY_ENUMERATION;
  }

  // 2: for "[" and \0
  method_c_custom_to_s_check_buffer_size(offset, 2, buffer_max);
  snprintf(&buffer[offset], 1 + 1, "%s", "[");
  offset += 1;
  int counter = 0;
  while (counter < max_len) {
    if (counter > 0) {
      // 3: ", " and \0
      method_c_custom_to_s_check_buffer_size(offset, 3, buffer_max);
      snprintf(&buffer[offset], 2 + 1, "%s", ", ");
      offset += 2;
    }

    VALUE array_element = rb_ary_entry(value, counter);
    method_c_custom_to_s_element(self, buffer, &offset, array_element, buffer_max, 1);
    counter += 1;
  }

  if (remaining_elements > 0) {
    // create another buffer, to find the exact number of characters
    // printed by the indeterminate %d
    char buffer_small[128];
    sprintf(&buffer_small[0], " (...%d more items)", remaining_elements);
    int buffer_small_len = strlen(buffer_small);

    // 2: for "]" and NULL
    method_c_custom_to_s_check_buffer_size(offset, buffer_small_len + 2, buffer_max);
    snprintf(&buffer[offset], buffer_small_len + 1, "%s", buffer_small);
    offset += buffer_small_len;
    snprintf(&buffer[offset], 1 + 1, "%s", "]");
    offset += 1;
  } else {
    // 2: for "]" and NULL
    method_c_custom_to_s_check_buffer_size(offset, 2, buffer_max);
    snprintf(&buffer[offset], 1 + 1, "%s", "]");
    offset += 1;
  }

  ret = rb_str_new_cstr(buffer);

  return ret;
}

struct method_c_custom_to_s_hash_iterator_state_s {
  VALUE self;
  int buffer_max;
  char *buffer;
  int *offset;
  int *counter;
  int max_len;
  int remaining_elements;
  char remaining_elements_shown;
};

int method_c_custom_to_s_hash_iterator(VALUE key, VALUE val, VALUE arg) {
  struct method_c_custom_to_s_hash_iterator_state_s *state = (void *) arg;

  if (*state->counter < state->max_len) {
    if (*state->counter > 0) {
      // 3: ", " and NULL
      method_c_custom_to_s_check_buffer_size(*state->offset, 3, state->buffer_max);
      snprintf(&state->buffer[*state->offset], 3, "%s", ", ");
        *state->offset += 2;
    }
    int buffer_key_max = MAX_STRING_LENGTH * 2;
    char buffer_key[buffer_key_max];
    int offset_key = 0;
    // hash values can be hashes themselves, so leave enough space for them
    int buffer_value_max = MAX_STRING_LENGTH * MAX_HASH_ENUMERATION * MAX_EXPECTED_NESTED_LEVELS;
    char buffer_value[buffer_value_max];
    int offset_value = 0;

    // build the key and the value separately, and either add them
    // together in a single step or stop adding if it would overflow
    // the buffer
    method_c_custom_to_s_element(state->self, buffer_key, &offset_key, key, buffer_key_max, 1);
    method_c_custom_to_s_element(state->self, buffer_value, &offset_value, val, buffer_value_max, 1);

    // +3 for "=>" and NULL
    if (*state->offset + offset_key + offset_value + 3 > state->buffer_max) {
      // stop adding: it would overflow the buffer
    } else {
      //printf("will add for offset_key %d\n", offset_key);
      snprintf(&state->buffer[*state->offset], offset_key + 1, "%s", buffer_key);
      *state->offset += offset_key;
      snprintf(&state->buffer[*state->offset], 3, "%s", "=>");
      *state->offset += 2;
      snprintf(&state->buffer[*state->offset], offset_value + 1, "%s", buffer_value);
      *state->offset += offset_value;
    }
  } else if (state->remaining_elements > 0) {
    if (state->remaining_elements_shown == 0) {
      char buffer_small[128];
      sprintf(&buffer_small[0], " (...%d more entries)", state->remaining_elements);
      int buffer_small_len = strlen(buffer_small);

      // +1 for NULL
      method_c_custom_to_s_check_buffer_size(*state->offset, buffer_small_len + 1, state->buffer_max);
      snprintf(&state->buffer[*state->offset], buffer_small_len + 1, "%s", buffer_small);
      *state->offset += buffer_small_len;

      state->remaining_elements_shown = 1;
    }
  }

  *state->counter += 1;

  return 0;
}

// from http://clalance.blogspot.com/2011/01/writing-ruby-extensions-in-c-part-10.html
VALUE method_c_custom_to_s_hash(VALUE self, VALUE value) {
  VALUE ret;
  // the buffer max size should be "big enough" and it's indeterminate
  int buffer_max = MAX_STRING_LENGTH * MAX_HASH_ENUMERATION * MAX_EXPECTED_NESTED_LEVELS;
  char buffer[buffer_max];

  int hash_len = RHASH_SIZE(value);
  int max_len = hash_len;
  int offset = 0;
  int remaining_elements = 0;
  if (max_len > MAX_HASH_ENUMERATION) {
    remaining_elements = max_len - MAX_HASH_ENUMERATION;
    max_len = MAX_HASH_ENUMERATION;
  }

  snprintf(&buffer[offset], 1 + 1, "%s", "{");
  offset += 1;


  int counter = 0;
  // pass state from this function into the callback function that
  // executes during each hash iteration
  struct method_c_custom_to_s_hash_iterator_state_s state;
  state.self = self;
  state.buffer_max = buffer_max;
  state.buffer = buffer;
  state.offset = &offset;
  state.counter = &counter;
  state.max_len = max_len;
  state.remaining_elements = remaining_elements;
  state.remaining_elements_shown = 0;
  rb_hash_foreach(value, &method_c_custom_to_s_hash_iterator, (VALUE) &state);

  // 2: "}" and \0
  method_c_custom_to_s_check_buffer_size(*state.offset, 2, state.buffer_max);
  snprintf(&buffer[offset], 1 + 1, "%s", "}");
  offset += 1;
  
  ret = rb_str_new_cstr(buffer);

  return ret;
}


typedef int32_t ucs4_t;

ucs4_t getu8c(char **src, int *illegal)
{
    static char umap[256] = { 0 };
    static int  umap_init_flag = 0;

    if (umap_init_flag == 0)
    {
        int i;

        for (i = 0; i < 0x100; ++i)
        {
            if (i < 0x80)
            {
                umap[i] = 1;
            }
            else if (i >= 0xc0 && i < 0xe0)
            {
                umap[i] = 2;
            }
            else if (i >= 0xe0 && i < 0xf0)
            {
                umap[i] = 3;
            }
            else if (i >= 0xf0 && i < 0xf8)
            {
                umap[i] = 4;
            }
            else if (i >= 0xf8 && i < 0xfc)
            {
                umap[i] = 5;
            }
            else if (i >= 0xfc && i < 0xfe)
            {
                umap[i] = 6;
            }
            else
            {
                umap[i] = 0;
            }
        }

        umap_init_flag = 1;
    }

    uint8_t *s = (uint8_t *)(*src);
    int r_illegal = 0;

    while (umap[*s] == 0)
    {
        ++s;
        ++r_illegal;
    }

    uint8_t *t;
    int byte_num;
    uint32_t uc;
    int i;

repeat_label:
    t = s;
    byte_num = umap[*s];
    uc = *s++ & (0xff >> byte_num);

    for (i = 1; i < byte_num; ++i)
    {
        if (umap[*s])
        {
            r_illegal += s - t;
            goto repeat_label;
        }
        else
        {
            uc = (uc << 6) + (*s & 0x3f);
            s += 1;
        }
    }

    *src = (char *)s;
    if (illegal)
    {
        *illegal = r_illegal;
    }

    return uc;
}

size_t u8decode(char const *str, ucs4_t *des, size_t n, int *illegal)
{
    if (n == 0)
        return 0;

    char *s = (char *)str;
    size_t i = 0;
    ucs4_t uc = 0;
    int r_illegal_all = 0, r_illegal;

    while ((uc = getu8c(&s, &r_illegal)))
    {
        if (i < (n - 1))
        {
            des[i++] = uc;
            r_illegal_all += r_illegal;
        }
        else
        {
            break;
        }
    }

    des[i] = 0;
    if (illegal)
    {
        *illegal = r_illegal_all + r_illegal;
    }

    return i;
}

# define IF_CAN_HOLD(left, n) do { \
    size_t m = (size_t)(n); \
    if ((size_t)(left) < (m + 1)) return -2; \
    (left) -= m; \
} while (0)

int putu8c(ucs4_t uc, char **des, size_t *left)
{
    if (uc < 0)
        return -1;

    if (uc < (0x1 << 7))
    {
        IF_CAN_HOLD(*left, 1);

        **des = (char)uc;
        *des += 1;
        **des = 0;

        return 1;
    }

    int byte_num;

    if (uc < (0x1 << 11))
    {
        byte_num = 2;
    }
    else if (uc < (0x1 << 16))
    {
        byte_num = 3;
    }
    else if (uc < (0x1 << 21))
    {
        byte_num = 4;
    }
    else if (uc < (0x1 << 26))
    {
        byte_num = 5;
    }
    else
    {
        byte_num = 6;
    }

    IF_CAN_HOLD(*left, byte_num);

    int i;
    for (i = byte_num - 1; i > 0; --i)
    {
        *(uint8_t *)(*des + i) = (uc & 0x3f) | 0x80;
        uc >>= 6;
    }

    *(uint8_t *)(*des) = uc | (0xff << (8 - byte_num));

    *des += byte_num;
    **des = 0;

    return byte_num;
}

size_t u8encode(ucs4_t *us, char *des, size_t n, int *illegal)
{
    if (n == 0)
        return 0;

    char *s = des;
    size_t left = n;
    size_t len = 0;
    int r_illegal = 0;

    *s = 0;
    while (*us)
    {
        int ret = putu8c(*us, &s, &left);
        printf("u8encode ret is %d\n", ret);
        if (ret > 0)
        {
            len += ret;
        }
        else if (ret == -1)
        {
            r_illegal += 1;
        }
        else
        {
            break;
        }

        ++us;
    }

    if (illegal)
    {
        *illegal = r_illegal;
    }

    return len;
}



/* Returns the bits of an 32-bit unsigned int variable over a given 
 * position. Begin bit is included, but end bit is excluded. */
static unsigned int get_bits(unsigned int char_reg, int begin, int end)
{
    int i = 0;
    unsigned int bits = 0;
    
    for (i = begin; i < end; i++) 
    {
        if (char_reg & (1 << i)) 
        {
            bits |= (1 << (i - begin));
        } 
    }
    
    return bits;
}

/* Counts the number of 8-bit bytes that are required to encode a given
 * Unicode code point using UTF-8 coding. */
static int get_num_bytes(unsigned int character)
{
    int num_bytes = 0;
    int i = 0;
    int bit_pos = 0;
    const int num_bits = sizeof(unsigned int) * CHAR_BIT;
    
    for (i = 0; i < num_bits; i++) 
    {
        if (character & (1 << i)) 
        {
            bit_pos = i;
        }
    }
    
    /* Double-byte encoding (e.g. Scandinavian letters) */
    if ((bit_pos > 6) && (bit_pos <= 10)) 
    {
        num_bytes = 2;
    } 
    /* Triple-byte encoding (e.g. CJK characters) */
    else if ((bit_pos > 10) && (bit_pos <= 15)) 
    {
        num_bytes = 3;
    } 
    /* Quad-byte encoding (e.g. special characters) */
    else if (bit_pos > 15) 
    {
        num_bytes = 4;
    } 
    /* Single-byte encoding (ASCII characters) */
    else 
    {
        num_bytes = 1;
    }
    
    return num_bytes;
}

/* 
 * Encodes the given character's Unicode code point using UTF-8 coding.
 * Parameters:
 *      character   Unicode code point as an unsigned integer.
 *      utf8        Array for UTF-8 encoded bytes (can be 1..4 bytes).
 */
int utf8_encode(unsigned int character, unsigned char utf8[]) 
{
    int num_bytes = 0;
    const int utf8_len = 4+1;
    int i = 0;
    unsigned int tmp_bits = 0;
    
    num_bytes = get_num_bytes(character);
    
    for (i = 0; i < utf8_len; i++) 
    {
        utf8[i] = '\0';
    }
    
    switch (num_bytes) 
    {
    case 1:
        /* utf8[0]: 0xxx|xxxx -> 7 databits (0..127) */
        tmp_bits = get_bits(character, 0, 8);
        utf8[0] = (unsigned char)tmp_bits;
        return 1;
        break;
        
    case 2:
        /* utf8[0]: 110x|xxxx 
           utf8[1]: 10xx|xxxx -> 11 databits (128..2047) */
        tmp_bits = get_bits(character, 0, 6);
        utf8[1] = (unsigned char)tmp_bits;
        
        tmp_bits = get_bits(character, 6, 11);
        utf8[0] = (unsigned char)tmp_bits;
        
        utf8[0] |= (1 << 6) | (1 << 7);
        utf8[1] |= (1 << 7);
        return 2;        
        break;
        
    case 3:
        /* utf8[0]: 1110|xxxx
           utf8[1]: 10xx|xxxx
           utf8[2]: 10xx|xxxx -> 16 databits (2048..65 535) */
        tmp_bits = get_bits(character, 0, 6);
        utf8[2] = (unsigned char)tmp_bits;
        
        tmp_bits = get_bits(character, 6, 12);
        utf8[1] = (unsigned char)tmp_bits;
        
        tmp_bits = get_bits(character, 12, 16);
        utf8[0] = (unsigned char)tmp_bits;
        
        utf8[0] |= (1 << 5) | (1 << 6) | (1 << 7);
        utf8[1] |= (1 << 7);
        utf8[2] |= (1 << 7);
        return 3;
        break;
        
    case 4:
        /* utf8[0]: 1111|0xxx
           utf8[1]: 10xx|xxxx
           utf8[2]: 10xx|xxxx
           utf8[3]: 10xx|xxxx -> 21 databits (65 536..2 097 151) */
        tmp_bits = get_bits(character, 0, 6);
        utf8[3] = (unsigned char)tmp_bits;
        
        tmp_bits = get_bits(character, 6, 12);
        utf8[2] = (unsigned char)tmp_bits;
        
        tmp_bits = get_bits(character, 12, 18);
        utf8[1] = (unsigned char)tmp_bits;
        
        tmp_bits = get_bits(character, 18, 21);
        utf8[0] = (unsigned char)tmp_bits;
        
        utf8[0] |= (1 << 4) | (1 << 5) | (1 << 6) | (1 << 7);
        utf8[1] |= (1 << 7);
        utf8[2] |= (1 << 7);
        utf8[3] |= (1 << 7);
        return 4;        
        break;
        
    default:
        break;
    }
    
}



// This is the method we added to test out passing parameters
// from https://silverhammermba.github.io/emberb/c/
VALUE method_c_custom_to_s(VALUE self, VALUE first) {
  VALUE ret;
  int buffer_max = MAX_STRING_LENGTH * 2;
  char buffer[buffer_max];
  
  switch (TYPE(first)) {
  case T_NIL:
    ret = rb_str_new_cstr("");
    break;
  case T_TRUE:
    ret = rb_str_new_cstr("true");
    break;
  case T_FALSE:
    ret = rb_str_new_cstr("false");
    break;      
  case T_FIXNUM: {
    sprintf(buffer, "%ld", FIX2LONG(first));
    ret = rb_str_new_cstr(buffer);
    break;
  }
  case T_FLOAT: {
    sprintf(buffer, "%.15g", RFLOAT_VALUE(first));
    ret = rb_str_new_cstr(buffer);
    break;
  }
  case T_SYMBOL: {
    char *name = (char *) rb_id2name(SYM2ID(first));
    int max_len = strlen(name);
    int offset = 0;
    // +1 for : +1 for NULL
    method_c_custom_to_s_check_buffer_size(offset, max_len + 2, buffer_max);
    snprintf(buffer, max_len + 2, ":%s", name);
    ret = rb_str_new_cstr(buffer);
    break;
  }
  case T_STRING: {
    int max_len = RSTRING_LEN(first);
    int remaining_characters = 0;
    if (max_len > MAX_STRING_LENGTH) {
      remaining_characters = max_len - MAX_STRING_LENGTH;
      max_len = MAX_STRING_LENGTH;
    }
    max_len += 1; // +1 for NULL written by snprintf
    method_c_custom_to_s_check_buffer_size(0, max_len, buffer_max);
    // something's strange with StringValueCStr and StringValuePtr,
    // because sprintf causes a buffer overflow but snprintf doesn't.
    snprintf(buffer, max_len, "%s", StringValuePtr(first));

    // -1 to write the first byte over the NULL added by snprintf
    int offset = max_len - 1;

    if (remaining_characters > 0) {
      char buffer_small[128];
      sprintf(&buffer_small[0], " (...%d more characters)", remaining_characters);
      int buffer_small_len = strlen(buffer_small);

      // +1 for NULL
      method_c_custom_to_s_check_buffer_size(offset, buffer_small_len + 1, buffer_max);
      snprintf(&buffer[offset], buffer_small_len + 1, "%s", buffer_small);
      offset += buffer_small_len;
    }


    
    /* char buffer_utf8_encoded[offset * 4]; */
    /* int counter = 0; */
    /* //int illegal = '_'; // character to use for illegal characters */
    /* counter += u8encode((ucs4_t *) &buffer, buffer_utf8_encoded, offset, NULL); */
    /* printf("counter is %d\n", counter); */
    /* printf("offset  is %d\n", offset); */
    /* ret = rb_utf8_str_new(buffer_utf8_encoded, counter); */

    
    char buffer_utf8_encoded[offset * 4];
    int counter = 0;
    while (counter < offset) {
      unsigned int character = buffer[counter];
      counter += utf8_encode(character, &buffer_utf8_encoded[counter]);
    }
    printf("counter is %d\n", counter);
    printf("offset  is %d\n", offset);
    ret = rb_utf8_str_new(buffer_utf8_encoded, counter);

    

    //ret = rb_utf8_str_new(buffer, offset);
    
    // this is 600%-900%x faster but reports the error:
    // in `generate': source sequence is illegal/malformed utf-8 (JSON::GeneratorError)
    // ret = rb_utf8_str_new(buffer, offset);
    // ret = rb_utf8_str_new(buffer, offset);

    // call Ruby function to utf8 encode instead of encode in C
    /* VALUE string_unencoded = rb_str_new_cstr(buffer); */
    /* ret = rb_funcall(self, rb_intern("custom_display_string_c_encode_utf8"), 1, string_unencoded); */
    break;
  }
  case T_ARRAY: {
    ret = method_c_custom_to_s_array(self, first);
    break;
  }
  case T_HASH: {
    ret = method_c_custom_to_s_hash(self, first);
    break;
  }
  /* case T_HASH: */
  case T_DATA:
    // captures Time, Date
  case T_FILE:
  case T_OBJECT:
    // Net::HTTP
    // Net::HTTPGenericRequest
  default: {
    ret = rb_funcall(self, rb_intern("custom_display_string_c_not_implemented"), 1, first);
    break;
  }
  }

  return ret;
}
