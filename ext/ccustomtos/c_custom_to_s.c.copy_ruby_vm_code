#include "ruby.h"

// Defining a space for information and references about the module to be stored internally
VALUE CCustomToS = Qnil;

// Prototype for the initialization method - Ruby calls this, not you
void Init_ccustomtos();

// Prototype for our methods, to be used by Init_ccustomtos
VALUE method_c_custom_to_s(VALUE, VALUE);

// The initialization method for this module
void Init_ccustomtos() {
  CCustomToS = rb_define_module("CCustomToS");
  rb_define_method(CCustomToS, "c_custom_to_s", method_c_custom_to_s, 1);
}

const int MAX_ARRAY_ENUMERATION = 10;
const int MAX_HASH_ENUMERATION = 10;
const int MAX_STRING_LENGTH = 100;
const int MAX_EXPECTED_NESTED_LEVELS = 4;

void method_c_custom_to_s_check_buffer_size(int offset, int string_len, int buffer_max) {
  if (offset + string_len > buffer_max) {
    // don't corrupt the buffer; throw exception
    rb_raise(rb_eRuntimeError, "method_c_custom_t_s_element would write %d bytes outside the buffer", offset + string_len - buffer_max);
  }
}

int method_c_custom_to_s_element(VALUE self, char *buffer, int *offset, VALUE element, int buffer_max, char quoted) {
  switch (TYPE(element)) {
  case T_NIL: {
    int string_len = 3; // +1 for NULL
    method_c_custom_to_s_check_buffer_size(*offset, string_len + 1, buffer_max);
    snprintf(&buffer[*offset], string_len + 1, "%s", "nil");
    *offset += string_len;
    break;
  }
  case T_STRING: {
    VALUE element_to_s = method_c_custom_to_s(self, element);
    int string_len = RSTRING_LEN(element_to_s);
    // +2 for the two "s. +1 for NULL
    method_c_custom_to_s_check_buffer_size(*offset, string_len + 3, buffer_max);
    if (quoted) {
      snprintf(&buffer[*offset], 1 + 1, "%s", "\"");
      *offset += 1;
    }
    // +1 for NULL
    snprintf(&buffer[*offset], string_len + 1, "%s", StringValuePtr(element_to_s));
    *offset += string_len;
    if (quoted) {
      snprintf(&buffer[*offset], 1 + 1, "%s", "\"");
      *offset += 1;
    }
    break;
  }
  default: {
    VALUE element_to_s = method_c_custom_to_s(self, element);
    method_c_custom_to_s_element(self, buffer, offset, element_to_s, buffer_max, 0);
    break;
  }
  }

  return 0;
}

VALUE method_c_custom_to_s_array(VALUE self, VALUE value) {
  VALUE ret;
  // the buffer max size should be "big enough" and it's indeterminate
  int buffer_max = MAX_STRING_LENGTH * MAX_ARRAY_ENUMERATION * MAX_EXPECTED_NESTED_LEVELS;
  char buffer[buffer_max];
  
  int array_len = RARRAY_LEN(value);
  int max_len = array_len;
  int offset = 0;
  int remaining_elements = 0;
  if (max_len > MAX_ARRAY_ENUMERATION) {
    remaining_elements = max_len - MAX_ARRAY_ENUMERATION;
    max_len = MAX_ARRAY_ENUMERATION;
  }

  // 2: for "[" and \0
  method_c_custom_to_s_check_buffer_size(offset, 2, buffer_max);
  snprintf(&buffer[offset], 1 + 1, "%s", "[");
  offset += 1;
  int counter = 0;
  while (counter < max_len) {
    if (counter > 0) {
      // 3: ", " and \0
      method_c_custom_to_s_check_buffer_size(offset, 3, buffer_max);
      snprintf(&buffer[offset], 2 + 1, "%s", ", ");
      offset += 2;
    }

    VALUE array_element = rb_ary_entry(value, counter);
    method_c_custom_to_s_element(self, buffer, &offset, array_element, buffer_max, 1);
    counter += 1;
  }

  if (remaining_elements > 0) {
    // create another buffer, to find the exact number of characters
    // printed by the indeterminate %d
    char buffer_small[128];
    sprintf(&buffer_small[0], " (...%d more items)", remaining_elements);
    int buffer_small_len = strlen(buffer_small);

    // 2: for "]" and NULL
    method_c_custom_to_s_check_buffer_size(offset, buffer_small_len + 2, buffer_max);
    snprintf(&buffer[offset], buffer_small_len + 1, "%s", buffer_small);
    offset += buffer_small_len;
    snprintf(&buffer[offset], 1 + 1, "%s", "]");
    offset += 1;
  } else {
    // 2: for "]" and NULL
    method_c_custom_to_s_check_buffer_size(offset, 2, buffer_max);
    snprintf(&buffer[offset], 1 + 1, "%s", "]");
    offset += 1;
  }

  ret = rb_str_new_cstr(buffer);

  return ret;
}

struct method_c_custom_to_s_hash_iterator_state_s {
  VALUE self;
  int buffer_max;
  char *buffer;
  int *offset;
  int *counter;
  int max_len;
  int remaining_elements;
  char remaining_elements_shown;
};

int method_c_custom_to_s_hash_iterator(VALUE key, VALUE val, VALUE arg) {
  struct method_c_custom_to_s_hash_iterator_state_s *state = (void *) arg;

  if (*state->counter < state->max_len) {
    if (*state->counter > 0) {
      // 3: ", " and NULL
      method_c_custom_to_s_check_buffer_size(*state->offset, 3, state->buffer_max);
      snprintf(&state->buffer[*state->offset], 3, "%s", ", ");
        *state->offset += 2;
    }
    int buffer_key_max = MAX_STRING_LENGTH * 2;
    char buffer_key[buffer_key_max];
    int offset_key = 0;
    // hash values can be hashes themselves, so leave enough space for them
    int buffer_value_max = MAX_STRING_LENGTH * MAX_HASH_ENUMERATION * MAX_EXPECTED_NESTED_LEVELS;
    char buffer_value[buffer_value_max];
    int offset_value = 0;

    // build the key and the value separately, and either add them
    // together in a single step or stop adding if it would overflow
    // the buffer
    method_c_custom_to_s_element(state->self, buffer_key, &offset_key, key, buffer_key_max, 1);
    method_c_custom_to_s_element(state->self, buffer_value, &offset_value, val, buffer_value_max, 1);

    // +3 for "=>" and NULL
    if (*state->offset + offset_key + offset_value + 3 > state->buffer_max) {
      // stop adding: it would overflow the buffer
    } else {
      //printf("will add for offset_key %d\n", offset_key);
      snprintf(&state->buffer[*state->offset], offset_key + 1, "%s", buffer_key);
      *state->offset += offset_key;
      snprintf(&state->buffer[*state->offset], 3, "%s", "=>");
      *state->offset += 2;
      snprintf(&state->buffer[*state->offset], offset_value + 1, "%s", buffer_value);
      *state->offset += offset_value;
    }
  } else if (state->remaining_elements > 0) {
    if (state->remaining_elements_shown == 0) {
      char buffer_small[128];
      sprintf(&buffer_small[0], " (...%d more entries)", state->remaining_elements);
      int buffer_small_len = strlen(buffer_small);

      // +1 for NULL
      method_c_custom_to_s_check_buffer_size(*state->offset, buffer_small_len + 1, state->buffer_max);
      snprintf(&state->buffer[*state->offset], buffer_small_len + 1, "%s", buffer_small);
      *state->offset += buffer_small_len;

      state->remaining_elements_shown = 1;
    }
  }

  *state->counter += 1;

  return 0;
}

// from http://clalance.blogspot.com/2011/01/writing-ruby-extensions-in-c-part-10.html
VALUE method_c_custom_to_s_hash(VALUE self, VALUE value) {
  VALUE ret;
  // the buffer max size should be "big enough" and it's indeterminate
  int buffer_max = MAX_STRING_LENGTH * MAX_HASH_ENUMERATION * MAX_EXPECTED_NESTED_LEVELS;
  char buffer[buffer_max];

  int hash_len = RHASH_SIZE(value);
  int max_len = hash_len;
  int offset = 0;
  int remaining_elements = 0;
  if (max_len > MAX_HASH_ENUMERATION) {
    remaining_elements = max_len - MAX_HASH_ENUMERATION;
    max_len = MAX_HASH_ENUMERATION;
  }

  snprintf(&buffer[offset], 1 + 1, "%s", "{");
  offset += 1;


  int counter = 0;
  // pass state from this function into the callback function that
  // executes during each hash iteration
  struct method_c_custom_to_s_hash_iterator_state_s state;
  state.self = self;
  state.buffer_max = buffer_max;
  state.buffer = buffer;
  state.offset = &offset;
  state.counter = &counter;
  state.max_len = max_len;
  state.remaining_elements = remaining_elements;
  state.remaining_elements_shown = 0;
  rb_hash_foreach(value, &method_c_custom_to_s_hash_iterator, (VALUE) &state);

  // 2: "}" and \0
  method_c_custom_to_s_check_buffer_size(*state.offset, 2, state.buffer_max);
  snprintf(&buffer[offset], 1 + 1, "%s", "}");
  offset += 1;
  
  ret = rb_str_new_cstr(buffer);

  return ret;
}

// ---------------------------------------------------------------
// It shouldn't be necessary to redefine (copy-paste) all this but
// ruby.h didn't export rb_enc_associate

typedef unsigned char  OnigUChar;
typedef unsigned int   OnigCodePoint;
typedef unsigned int   OnigCtype;

/*                                                                                                                                                                          
 * Onig casefold/case mapping flags and related definitions                                                                                                                 
 *                                                                                                                                                                          
 * Subfields (starting with 0 at LSB):                                                                                                                                      
 *   0-2: Code point count in casefold.h                                                                                                                                    
 *   3-12: Index into SpecialCaseMapping array in casefold.h                                                                                                                
 *   13-22: Case folding/mapping flags                                                                                                                                      
 */
typedef unsigned int OnigCaseFoldType; /* case fold flag */

#define ONIGENC_MAX_COMP_CASE_FOLD_CODE_LEN       3

typedef struct {
  int byte_len;  /* argument(original) character(s) byte length */
  int code_len;  /* number of code */
  OnigCodePoint code[ONIGENC_MAX_COMP_CASE_FOLD_CODE_LEN];
} OnigCaseFoldCodeItem;

typedef int (*OnigApplyAllCaseFoldFunc)(OnigCodePoint from, OnigCodePoint* to, int to_len, void* arg);

typedef struct OnigEncodingTypeST {
  int    (*precise_mbc_enc_len)(const OnigUChar* p,const OnigUChar* e, const struct OnigEncodingTypeST* enc);
  const char*   name;
  int           max_enc_len;
  int           min_enc_len;
  int    (*is_mbc_newline)(const OnigUChar* p, const OnigUChar* end, const struct OnigEncodingTypeST* enc);
  OnigCodePoint (*mbc_to_code)(const OnigUChar* p, const OnigUChar* end, const struct OnigEncodingTypeST* enc);
  int    (*code_to_mbclen)(OnigCodePoint code, const struct OnigEncodingTypeST* enc);
  int    (*code_to_mbc)(OnigCodePoint code, OnigUChar *buf, const struct OnigEncodingTypeST* enc);
  int    (*mbc_case_fold)(OnigCaseFoldType flag, const OnigUChar** pp, const OnigUChar* end, OnigUChar* to, const struct OnigEncodingTypeST* enc);
  int    (*apply_all_case_fold)(OnigCaseFoldType flag, OnigApplyAllCaseFoldFunc f, void* arg, const struct OnigEncodingTypeST* enc);
  int    (*get_case_fold_codes_by_str)(OnigCaseFoldType flag, const OnigUChar* p, const OnigUChar* end, OnigCaseFoldCodeItem acs[], const struct OnigEncodingTypeST* enc);
  int    (*property_name_to_ctype)(const struct OnigEncodingTypeST* enc, const OnigUChar* p, const OnigUChar* end);
  int    (*is_code_ctype)(OnigCodePoint code, OnigCtype ctype, const struct OnigEncodingTypeST* enc);
  int    (*get_ctype_code_range)(OnigCtype ctype, OnigCodePoint* sb_out, const OnigCodePoint* ranges[], const struct OnigEncodingTypeST* enc);
  OnigUChar* (*left_adjust_char_head)(const OnigUChar* start, const OnigUChar* p, const OnigUChar* end, const struct OnigEncodingTypeST* enc);
  int    (*is_allowed_reverse_match)(const OnigUChar* p, const OnigUChar* end, const struct OnigEncodingTypeST* enc);
  int    (*case_map)(OnigCaseFoldType* flagP, const OnigUChar** pp, const OnigUChar* end, OnigUChar* to, OnigUChar* to_end, const struct OnigEncodingTypeST* enc);
  int ruby_encoding_index;
  unsigned int  flags;
} OnigEncodingType;


typedef OnigEncodingType rb_raw_encoding;
typedef const OnigEncodingType rb_encoding;

enum ruby_encoding_consts {
    RUBY_ENCODING_INLINE_MAX = 127,
    RUBY_ENCODING_SHIFT = (RUBY_FL_USHIFT+10),
    RUBY_ENCODING_MASK = (RUBY_ENCODING_INLINE_MAX<<RUBY_ENCODING_SHIFT
                          /* RUBY_FL_USER10..RUBY_FL_USER16 */),
    RUBY_ENCODING_MAXNAMELEN = 42
};

#define ENCODING_INLINE_MAX RUBY_ENCODING_INLINE_MAX

#define RB_ENCODING_GET_INLINED(obj) \
    (int)((RBASIC(obj)->flags & RUBY_ENCODING_MASK)>>RUBY_ENCODING_SHIFT)

#define ENCODING_GET_INLINED(obj) RB_ENCODING_GET_INLINED(obj)

// should reuse existing variable from ruby, not redifine new one
static ID id_encoding;

ID
rb_id_encoding(void)
{
    CONST_ID(id_encoding, "encoding");
    return id_encoding;
}

enum ruby_preserved_encindex {
    RUBY_ENCINDEX_ASCII_8BIT,
    RUBY_ENCINDEX_UTF_8,
    RUBY_ENCINDEX_US_ASCII,

    /* preserved indexes */
    RUBY_ENCINDEX_UTF_16BE,
    RUBY_ENCINDEX_UTF_16LE,
    RUBY_ENCINDEX_UTF_32BE,
    RUBY_ENCINDEX_UTF_32LE,
    RUBY_ENCINDEX_UTF_16,
    RUBY_ENCINDEX_UTF_32,
    RUBY_ENCINDEX_UTF8_MAC,

    /* for old options of regexp */
    RUBY_ENCINDEX_EUC_JP,
    RUBY_ENCINDEX_Windows_31J,

    RUBY_ENCINDEX_BUILTIN_MAX
};

#define ENCINDEX_ASCII_8BIT  RUBY_ENCINDEX_ASCII_8BIT
#define ENCINDEX_UTF_8       RUBY_ENCINDEX_UTF_8
#define ENCINDEX_US_ASCII    RUBY_ENCINDEX_US_ASCII

static int
enc_get_index_str(VALUE str)
{
    int i = ENCODING_GET_INLINED(str);
    if (i == ENCODING_INLINE_MAX) {
        VALUE iv;

#if 0
        iv = rb_ivar_get(str, rb_id_encoding());
        i = NUM2INT(iv);
#else
        /*                                                                                                                                                                  
         * Tentatively, assume ASCII-8BIT, if encoding index instance                                                                                                       
         * variable is not found.  This can happen when freeing after                                                                                                       
         * all instance variables are removed in `obj_free`.                                                                                                                
         */
        iv = rb_attr_get(str, rb_id_encoding());
        i = NIL_P(iv) ? ENCINDEX_ASCII_8BIT : NUM2INT(iv);
#endif
    }
    return i;
}


#define RB_VM_LOCK_ENTER_LEV(levp) rb_vm_lock_enter(levp, __FILE__, __LINE__)
#define RB_VM_LOCK_LEAVE_LEV(levp) rb_vm_lock_leave(levp, __FILE__, __LINE__)

#define RB_VM_LOCK_ENTER()  { unsigned int _lev; RB_VM_LOCK_ENTER_LEV(&_lev);
#define RB_VM_LOCK_LEAVE()    RB_VM_LOCK_LEAVE_LEV(&_lev); }

static struct enc_table {
    struct rb_encoding_entry *list;
    int count;
    int size;
    st_table *names;
} global_enc_table;

static rb_encoding *global_enc_ascii,
                   *global_enc_utf_8,
                   *global_enc_us_ascii;

#define GLOBAL_ENC_TABLE_ENTER(enc_table) struct enc_table *enc_table = &global_enc_table; RB_VM_LOCK_ENTER()
#define GLOBAL_ENC_TABLE_LEAVE()                                                           RB_VM_LOCK_LEAVE()
#define GLOBAL_ENC_TABLE_EVAL(enc_table, expr) do { \
    GLOBAL_ENC_TABLE_ENTER(enc_table); \
    { \
        expr; \
    } \
    GLOBAL_ENC_TABLE_LEAVE(); \
} while (0)

#define ENC_INDEX_MASK (~(~0U<<24))

#define ENC_TO_ENCINDEX(enc) (int)((enc)->ruby_encoding_index & ENC_INDEX_MASK)

static const rb_data_type_t encoding_data_type = {
    "encoding",
    {0, 0, 0,},
    0, 0, RUBY_TYPED_FREE_IMMEDIATELY
};

#define is_data_encoding(obj) (RTYPEDDATA_P(obj) && RTYPEDDATA_TYPE(obj) == &encoding_data_type)
#define is_obj_encoding(obj) (RB_TYPE_P((obj), T_DATA) && is_data_encoding(obj))

int
rb_enc_to_index(rb_encoding *enc)
{
    return enc ? ENC_TO_ENCINDEX(enc) : 0;
}

rb_encoding *
rb_enc_from_index(int index)
{
    rb_encoding *enc;

    switch (index) {
      case ENCINDEX_ASCII_8BIT:    return global_enc_ascii;
      case ENCINDEX_UTF_8:    return global_enc_utf_8;
      case ENCINDEX_US_ASCII: return global_enc_us_ascii;
      default:
	GLOBAL_ENC_TABLE_EVAL(enc_table,
                              enc = enc_from_index(enc_table, index));
        return enc;
    }
}

static int
check_encoding(rb_encoding *enc)
{
    int index = rb_enc_to_index(enc);
    if (rb_enc_from_index(index) != enc)
        return -1;
    if (rb_enc_autoload_p(enc)) {
        index = rb_enc_autoload(enc);
    }
    return index;
}

static int
enc_check_encoding(VALUE obj)
{
    if (!is_obj_encoding(obj)) {
        return -1;
    }
    return check_encoding(RDATA(obj)->data);
}

int
rb_enc_get_index(VALUE obj)
{
    int i = -1;
    VALUE tmp;

    if (SPECIAL_CONST_P(obj)) {
        if (!SYMBOL_P(obj)) return -1;
        obj = rb_sym2str(obj);
    }
    switch (BUILTIN_TYPE(obj)) {
      case T_STRING:
      case T_SYMBOL:
      case T_REGEXP:
        i = enc_get_index_str(obj);
        break;
      case T_FILE:
        tmp = rb_funcallv(obj, rb_intern("internal_encoding"), 0, 0);
        if (NIL_P(tmp)) {
            tmp = rb_funcallv(obj, rb_intern("external_encoding"), 0, 0);
        }
        if (is_obj_encoding(tmp)) {
            i = enc_check_encoding(tmp);
        }
        break;
      case T_DATA:
        if (is_data_encoding(obj)) {
            i = enc_check_encoding(obj);
        }
        break;
      default:
        break;
    }
    return i;
}





VALUE
rb_enc_associate_index(VALUE obj, int idx)
{
    rb_encoding *enc;
    int oldidx, oldtermlen, termlen;

/*    enc_check_capable(obj);*/
    rb_check_frozen(obj);
    oldidx = rb_enc_get_index(obj);
    if (oldidx == idx)
        return obj;
    if (SPECIAL_CONST_P(obj)) {
        rb_raise(rb_eArgError, "cannot set encoding");
    }
    enc = must_encindex(idx);
    if (!ENC_CODERANGE_ASCIIONLY(obj) ||
        !rb_enc_asciicompat(enc)) {
        ENC_CODERANGE_CLEAR(obj);
    }
    termlen = rb_enc_mbminlen(enc);
    oldtermlen = rb_enc_mbminlen(rb_enc_from_index(oldidx));
    if (oldtermlen != termlen && RB_TYPE_P(obj, T_STRING)) {
        rb_str_change_terminator_length(obj, oldtermlen, termlen);
    }
    enc_set_index(obj, idx);
    return obj;
}

/* VALUE */
/* rb_enc_associate(VALUE obj, rb_encoding *enc) */
/* { */
/*     return rb_enc_associate_index(obj, rb_enc_to_index(enc)); */
/* } */


// ---------------------------------------------------------------


// This is the method we added to test out passing parameters
// from https://silverhammermba.github.io/emberb/c/
VALUE method_c_custom_to_s(VALUE self, VALUE first) {
  VALUE ret;
  int buffer_max = MAX_STRING_LENGTH * 2;
  char buffer[buffer_max];
  
  switch (TYPE(first)) {
  case T_NIL:
    ret = rb_str_new_cstr("");
    break;
  case T_TRUE:
    ret = rb_str_new_cstr("true");
    break;
  case T_FALSE:
    ret = rb_str_new_cstr("false");
    break;      
  case T_FIXNUM: {
    sprintf(buffer, "%ld", FIX2LONG(first));
    ret = rb_str_new_cstr(buffer);
    break;
  }
  case T_FLOAT: {
    sprintf(buffer, "%.15g", RFLOAT_VALUE(first));
    ret = rb_str_new_cstr(buffer);
    break;
  }
  case T_SYMBOL: {
    char *name = (char *) rb_id2name(SYM2ID(first));
    int max_len = strlen(name);
    int offset = 0;
    // +1 for : +1 for NULL
    method_c_custom_to_s_check_buffer_size(offset, max_len + 2, buffer_max);
    snprintf(buffer, max_len + 2, ":%s", name);
    ret = rb_str_new_cstr(buffer);
    break;
  }
  case T_STRING: {
    int max_len = RSTRING_LEN(first);
    int remaining_characters = 0;
    if (max_len > MAX_STRING_LENGTH) {
      remaining_characters = max_len - MAX_STRING_LENGTH;
      max_len = MAX_STRING_LENGTH;
    }
    max_len += 1; // +1 for NULL written by snprintf
    method_c_custom_to_s_check_buffer_size(0, max_len, buffer_max);
    // something's strange with StringValueCStr and StringValuePtr,
    // because sprintf causes a buffer overflow but snprintf doesn't.
    snprintf(buffer, max_len, "%s", StringValuePtr(first));

    // -1 to write the first byte over the NULL added by snprintf
    int offset = max_len - 1;

    if (remaining_characters > 0) {
      char buffer_small[128];
      sprintf(&buffer_small[0], " (...%d more characters)", remaining_characters);
      int buffer_small_len = strlen(buffer_small);

      // +1 for NULL
      method_c_custom_to_s_check_buffer_size(offset, buffer_small_len + 1, buffer_max);
      snprintf(&buffer[offset], buffer_small_len + 1, "%s", buffer_small);
      offset += buffer_small_len;
    }

    // this is 600%-900%x faster but reports the error:
    // in `generate': source sequence is illegal/malformed utf-8 (JSON::GeneratorError)
    /* ret = rb_str_new_cstr(buffer); */
    /* rb_enc_associate(ret, rb_utf8_encoding()); */

    /* str = rb_str_encode(str, rb_enc_from_encoding(enc), 0, Qnil); */
    /* ret = rb_str_encode(buffer, offset); */
    
    //ret = rb_utf8_str_new(buffer, offset);
    //ret = rb_str_new_cstr(buffer);

    // call Ruby function to utf8 encode instead of encode in C
    VALUE string_unencoded = rb_str_new_cstr(buffer);
    ret = rb_funcall(self, rb_intern("custom_display_string_c_encode_utf8"), 1, string_unencoded);
    break;
  }
  /* case T_ARRAY: { */
  /*   ret = method_c_custom_to_s_array(self, first); */
  /*   break; */
  /* } */
  /* case T_HASH: { */
  /*   ret = method_c_custom_to_s_hash(self, first); */
  /*   break; */
  /* } */
  case T_ARRAY:
  case T_HASH:
  case T_DATA:
    // captures Time, Date
  case T_FILE:
  case T_OBJECT:
    // Net::HTTP
    // Net::HTTPGenericRequest
  default: {
    ret = rb_funcall(self, rb_intern("custom_display_string_c_not_implemented"), 1, first);
    break;
  }
  }

  return ret;
}
